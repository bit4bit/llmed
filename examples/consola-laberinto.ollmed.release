#<llmed-code context='Entidades' digest='a4f1cc55bc6df7ea9b8810db8b7fe7da958da8e380bc621653e1e9f71120ef9f' after='9c71793151b01994e536320eeb6849008daecd3854c3e8d702f2cb7b7795cf34'>
# LLMED-COMPILED
class Laberinto
  attr_reader :grid, :width, :height

  def initialize(width, height)
    @width = width
    @height = height
    @grid = Array.new(height) { Array.new(width, '#') }
    generate
  end

  def generate
    start_x, start_y = 1, 1
    end_x, end_y = width - 2, height - 2
    stack = [[start_x, start_y]]
    @grid[start_y][start_x] = '.'

    while stack.any?
      current_x, current_y = stack.last
      neighbors = unvisited_neighbors(current_x, current_y)

      if neighbors.empty?
        stack.pop
      else
        next_x, next_y = neighbors.sample
        @grid[next_y][next_x] = '.'
        @grid[(current_y + next_y) / 2][(current_x + next_x) / 2] = '.'
        stack.push([next_x, next_y])
      end
    end

    @grid[end_y][end_x] = '>'
  end

  def unvisited_neighbors(x, y)
    [[x+2, y], [x-2, y], [x, y+2], [x, y-2]].select do |nx, ny|
      nx.between?(1, width-2) && ny.between?(1, height-2) && @grid[ny][nx] == '#'
    end
  end

  def to_s
    @grid.map(&:join).join("\n")
  end
end

class Jugador
  attr_reader :x, :y

  def initialize(x, y)
    @x = x
    @y = y
  end

  def move(dx, dy, laberinto)
    new_x = @x + dx
    new_y = @y + dy
    if valid_move?(new_x, new_y, laberinto)
      @x = new_x
      @y = new_y
    end
  end

  def valid_move?(x, y, laberinto)
    x.between?(0, laberinto.width - 1) &&
    y.between?(0, laberinto.height - 1) &&
    laberinto.grid[y][x] != '#'
  end
end

class Salida
  attr_reader :x, :y

  def initialize(laberinto)
    @x, @y = find_exit(laberinto)
  end

  def find_exit(laberinto)
    laberinto.grid.each_with_index do |row, y|
      row.each_with_index do |cell, x|
        return [x, y] if cell == '>'
      end
    end
  end
end
#</llmed-code>

#<llmed-code context='Logica' digest='9c71793151b01994e536320eeb6849008daecd3854c3e8d702f2cb7b7795cf34' after='9171c2f0cb1339b37dbddeb685659644a66ca990bddb9df8a57513883edbbc95'>
# LLMED-COMPILED
require 'fileutils'

class Juego
  def initialize(laberinto)
    @laberinto = laberinto
    @jugador = Jugador.new(1, 1)
    @salida = Salida.new(laberinto)
    @pasos = 0
    @history_file = File.join(Dir.home, 'consola-laberinto.history')
  end

  def run
    loop do
      render
      input = get_input
      break if input == 'q'
      process_input(input)
      @pasos += 1
      break if game_over?
    end
    save_score
  end

  private

  def render
    system('clear') || system('cls')
    puts "Pasos: #{@pasos}"
    @laberinto.grid.each_with_index do |row, y|
      puts row.map.with_index { |cell, x|
        if @jugador.x == x && @jugador.y == y
          '@'
        else
          cell
        end
      }.join
    end
  end

  def get_input
    STDIN.getch
  end

  def process_input(input)
    case input
    when 'w' then @jugador.move(0, -1, @laberinto)
    when 's' then @jugador.move(0, 1, @laberinto)
    when 'a' then @jugador.move(-1, 0, @laberinto)
    when 'd' then @jugador.move(1, 0, @laberinto)
    end
  end

  def game_over?
    @jugador.x == @salida.x && @jugador.y == @salida.y
  end

  def save_score
    FileUtils.mkdir_p(File.dirname(@history_file))
    File.open(@history_file, 'a') do |file|
      file.puts "#{Time.now}: Laberinto #{@laberinto.width}x#{@laberinto.height} completado en #{@pasos} pasos."
    end
  end
end
#</llmed-code>

#<llmed-code context='Main' digest='9171c2f0cb1339b37dbddeb685659644a66ca990bddb9df8a57513883edbbc95' after=''>
# LLMED-COMPILED
require 'io/console'

def get_dimensions
  print "Ingrese el ancho del laberinto: "
  width = gets.chomp.to_i
  print "Ingrese el alto del laberinto: "
  height = gets.chomp.to_i
  [width, height]
end

width, height = get_dimensions
laberinto = Laberinto.new(width, height)
juego = Juego.new(laberinto)
juego.run

puts "Â¡Juego terminado!"
#</llmed-code>